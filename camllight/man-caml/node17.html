<HEAD>
<TITLE>The unix library: Unix system calls</TITLE>
</HEAD>
<BODY>
<A HREF="node18.html"><IMG SRC="next_motif.gif"></A>
<A HREF="node16.html"><IMG SRC="previous_motif.gif"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif"></A>
<HR>
<H1>The unix library: Unix system calls</H1>
<P>
The <tt>unix</tt> library (distributed in <tt>contrib/libunix</tt>) makes many Unix
system calls and system-related library functions available to Caml
Light programs. This chapter describes briefly the functions provided.
Refer to sections 2 and 3 of the Unix manual for more details on the
behavior of these functions. <P>
Not all functions are provided by all Unix variants. If some functions
are not available, they will raise <tt>Invalid_arg</tt> when called.<P>
Programs that use the <tt>unix</tt> library must be linked in ``custom
runtime'' mode, as follows:
<pre>
        camlc -custom <i>other options</i> unix.zo <i>other files</i> -lunix
</pre>
For interactive use of the <tt>unix</tt> library, run <tt>camllight camlunix</tt>.<P>
<dl><dt><b>Mac:</b><dd>
This library is not available.
</dl><P>
<dl><dt><b>PC:</b><dd>
This library is not available.
</dl><P>

<H2><tt>unix</tt>: interface to the Unix system </H2>
<P>
<A name="s:unix"></A>

<H3>Error report </H3>
<pre>
type error =
    ENOERR
  | EPERM               (* Not owner *)
  | ENOENT              (* No such file or directory *)
  | ESRCH               (* No such process *)
  | EINTR               (* Interrupted system call *)
  | EIO                 (* I/O error *)
  | ENXIO               (* No such device or address *)
  | E2BIG               (* Arg list too long *)
  | ENOEXEC             (* Exec format error *)
  | EBADF               (* Bad file number *)
  | ECHILD              (* No children *)
  | EAGAIN              (* No more processes *)
  | ENOMEM              (* Not enough core *)
  | EACCES              (* Permission denied *)
  | EFAULT              (* Bad address *)
  | ENOTBLK             (* Block device required *)
  | EBUSY               (* Mount device busy *)
  | EEXIST              (* File exists *)
  | EXDEV               (* Cross-device link *)
  | ENODEV              (* No such device *)
  | ENOTDIR             (* Not a directory*)
  | EISDIR              (* Is a directory *)
  | EINVAL              (* Invalid argument *)
  | ENFILE              (* File table overflow *)
  | EMFILE              (* Too many open files *)
  | ENOTTY              (* Not a typewriter *)
  | ETXTBSY             (* Text file busy *)
  | EFBIG               (* File too large *)
  | ENOSPC              (* No space left on device *)
  | ESPIPE              (* Illegal seek *)
  | EROFS               (* Read-only file system *)
  | EMLINK              (* Too many links *)
  | EPIPE               (* Broken pipe *)
  | EDOM                (* Argument too large *)
  | ERANGE              (* Result too large *)
  | EWOULDBLOCK         (* Operation would block *)
  | EINPROGRESS         (* Operation now in progress *)
  | EALREADY            (* Operation already in progress *)
  | ENOTSOCK            (* Socket operation on non-socket *)
  | EDESTADDRREQ        (* Destination address required *)
  | EMSGSIZE            (* Message too long *)
  | EPROTOTYPE          (* Protocol wrong type for socket *)
  | ENOPROTOOPT         (* Protocol not available *)
  | EPROTONOSUPPORT     (* Protocol not supported *)
  | ESOCKTNOSUPPORT     (* Socket type not supported *)
  | EOPNOTSUPP          (* Operation not supported on socket *)
  | EPFNOSUPPORT        (* Protocol family not supported *)
  | EAFNOSUPPORT        (* Address family not supported by protocol family *)
  | EADDRINUSE          (* Address already in use *)
  | EADDRNOTAVAIL       (* Can't assign requested address *)
  | ENETDOWN            (* Network is down *)
  | ENETUNREACH         (* Network is unreachable *)
  | ENETRESET           (* Network dropped connection on reset *)
  | ECONNABORTED        (* Software caused connection abort *)
  | ECONNRESET          (* Connection reset by peer *)
  | ENOBUFS             (* No buffer space available *)
  | EISCONN             (* Socket is already connected *)
  | ENOTCONN            (* Socket is not connected *)
  | ESHUTDOWN           (* Can't send after socket shutdown *)
  | ETOOMANYREFS        (* Too many references: can't splice *)
  | ETIMEDOUT           (* Connection timed out *)
  | ECONNREFUSED        (* Connection refused *)
  | ELOOP               (* Too many levels of symbolic links *)
  | ENAMETOOLONG        (* File name too long *)
  | EHOSTDOWN           (* Host is down *)
  | EHOSTUNREACH        (* No route to host *)
  | ENOTEMPTY           (* Directory not empty *)
  | EPROCLIM            (* Too many processes *)
  | EUSERS              (* Too many users *)
  | EDQUOT              (* Disc quota exceeded *)
  | ESTALE              (* Stale NFS file handle *)
  | EREMOTE             (* Too many levels of remote in path *)
  | EIDRM               (* Identifier removed *)
  | EDEADLK             (* Deadlock condition. *)
  | ENOLCK              (* No record locks available. *)
  | ENOSYS              (* Function not implemented *)
  | EUNKNOWNERR
</pre>
<dl><dd>
 The type of error codes. 
</dl>
<pre>
exception Unix_error of error * string * string
</pre>
<dl><dd>
 Raised by the system calls below when an error is encountered.
           The first component is the error code; the second component
           is the function name; the third component is the string parameter
           to the function, if it has one, or the empty string otherwise. 
</dl>
<pre>
value error_message : error -&gt; string
</pre>
<dl><dd>
 Return a string describing the given error code. 
</dl>
<pre>
value handle_unix_error : ('a -&gt; 'b) -&gt; 'a -&gt; 'b
</pre>
<dl><dd>
 <tt>handle_unix_error f x</tt> applies <tt>f</tt> to <tt>x</tt> and returns the result.
           If the exception <tt>Unix_error</tt> is raised, it prints a message
           describing the error and exits with code 2. 
</dl>
<H3>Interface with the parent process </H3>
<pre>
value environment : unit -&gt; string vect
</pre>
<dl><dd>
 Return the process environment, as an array of strings
           with the format ``variable=value''. See also <tt>sys__getenv</tt>. 
</dl>
<H3>Process handling </H3>
<pre>
type process_status =
    WEXITED of int
  | WSIGNALED of int * bool
  | WSTOPPED of int
</pre>
<dl><dd>
 The termination status of a process. <tt>WEXITED</tt> means that the
           process terminated normally by <tt>exit</tt>; the argument is the return
           code. <tt>WSIGNALED</tt> means that the process was killed by a signal;
           the first argument is the signal number, the second argument
           indicates whether a ``core dump'' was performed. <tt>WSTOPPED</tt> means
           that the process was stopped by a signal; the argument is the
           signal number. 
</dl>
<pre>
type wait_flag =
    WNOHANG
  | WUNTRACED
</pre>
<dl><dd>
 Flags for <tt>waitopt</tt> and <tt>waitpid</tt>.
           <tt>WNOHANG</tt> means do not block if no child has
           died yet, but immediately return with a pid equal to 0.
           <tt>WUNTRACED</tt> means report also the children that receive stop
           signals. 
</dl>
<pre>
value execv : string -&gt; string vect -&gt; unit
</pre>
<dl><dd>
 <tt>execv prog args</tt> execute the program in file <tt>prog</tt>, with
           the arguments <tt>args</tt>, and the current process environment. 
</dl>
<pre>
value execve : string -&gt; string vect -&gt; string vect -&gt; unit
</pre>
<dl><dd>
 Same as <tt>execv</tt>, except that the third argument provides the
           environment to the program executed. 
</dl>
<pre>
value execvp : string -&gt; string vect -&gt; unit
</pre>
<dl><dd>
 Same as <tt>execv</tt>, except that the program is searched in the path. 
</dl>
<pre>
value fork : unit -&gt; int
</pre>
<dl><dd>
 Fork a new process. The returned integer is 0 for the child
           process, the pid of the child process for the parent process. 
</dl>
<pre>
value wait : unit -&gt; int * process_status
</pre>
<dl><dd>
 Wait until one of the children processes die, and return its pid
           and termination status. 
</dl>
<pre>
value waitopt : wait_flag list -&gt; int * process_status
</pre>
<dl><dd>
 Same as <tt>wait</tt>, but takes a list of options to avoid blocking,
           or also report stopped children. The pid returned is 0 if no
           child has changed status. 
</dl>
<pre>
value waitpid : wait_flag list -&gt; int -&gt; int * process_status
</pre>
<dl><dd>
 Same as <tt>waitopt</tt>, but waits for the process whose pid is given.
           Negative pid arguments represent process groups. 
</dl>
<pre>
value system : string -&gt; process_status
</pre>
<dl><dd>
 Execute the given command, wait until it terminates, and return
           its termination status. The string is interpreted by the shell
           <tt>/bin/sh</tt> and therefore can contain redirections, quotes, variables,
           etc. The result <tt>WEXITED 127</tt> indicates that the shell couldn't
           be executed. 
</dl>
<pre>
value getpid : unit -&gt; int
</pre>
<dl><dd>
 Return the pid of the process. 
</dl>
<pre>
value getppid : unit -&gt; int
</pre>
<dl><dd>
 Return the pid of the parent process. 
</dl>
<pre>
value nice : int -&gt; int
</pre>
<dl><dd>
 Change the process priority. The integer argument is added to the
           ``nice'' value. (Higher values of the ``nice'' value mean
           lower priorities.) Return the new nice value. 
</dl>
<H3>Basic file input/output </H3>
<pre>
type file_descr
</pre>
<dl><dd>
 The abstract type of file descriptors. 
</dl>
<pre>
value stdin : file_descr
value stdout : file_descr
value stderr : file_descr
</pre>
<dl><dd>
 File descriptors for standard input, standard output and
           standard error. 
</dl>
<pre>
type open_flag =
    O_RDONLY                            (* Open for reading *)
  | O_WRONLY                            (* Open for writing *)
  | O_RDWR                              (* Open for reading and writing *)
  | O_NDELAY                            (* Open in non-blocking mode *)
  | O_APPEND                            (* Open for append *)
  | O_CREAT                             (* Create if nonexistent *)
  | O_TRUNC                             (* Truncate to 0 length if existing *)
  | O_EXCL                              (* Fail if existing *)
</pre>
<dl><dd>
 The flags to <tt>open</tt>. 
</dl>
<pre>
type file_perm == int
</pre>
<dl><dd>
 The type of file access rights. 
</dl>
<pre>
value open : string -&gt; open_flag list -&gt; file_perm -&gt; file_descr
</pre>
<dl><dd>
 Open the named file with the given flags. Third argument is
           the permissions to give to the file if it is created. Return
           a file descriptor on the named file. 
</dl>
<pre>
value close : file_descr -&gt; unit
</pre>
<dl><dd>
 Close a file descriptor. 
</dl>
<pre>
value read : file_descr -&gt; string -&gt; int -&gt; int -&gt; int
</pre>
<dl><dd>
 <tt>read fd buff start len</tt> reads <tt>len</tt> characters from descriptor
           <tt>fd</tt>, storing them in string <tt>buff</tt>, starting at position <tt>ofs</tt>
           in string <tt>buff</tt>. Return the number of characters actually read. 
</dl>
<pre>
value write : file_descr -&gt; string -&gt; int -&gt; int -&gt; int
</pre>
<dl><dd>
 <tt>write fd buff start len</tt> writes <tt>len</tt> characters to descriptor
           <tt>fd</tt>, taking them from string <tt>buff</tt>, starting at position <tt>ofs</tt>
           in string <tt>buff</tt>. Return the number of characters actually
           written. 
</dl>
<H3>Interfacing with the standard input/output library (module io). </H3>
<pre>
value in_channel_of_descr : file_descr -&gt; in_channel
</pre>
<dl><dd>
 Create an input channel reading from the given descriptor. 
</dl>
<pre>
value out_channel_of_descr : file_descr -&gt; out_channel
</pre>
<dl><dd>
 Create an output channel writing on the given descriptor. 
</dl>
<pre>
value descr_of_in_channel : in_channel -&gt; file_descr
</pre>
<dl><dd>
 Return the descriptor corresponding to an input channel. 
</dl>
<pre>
value descr_of_out_channel : out_channel -&gt; file_descr
</pre>
<dl><dd>
 Return the descriptor corresponding to an output channel. 
</dl>
<H3>Seeking and truncating </H3>
<pre>
type seek_command =
    SEEK_SET
  | SEEK_CUR
  | SEEK_END
</pre>
<dl><dd>
 Positioning modes for <tt>lseek</tt>. <tt>SEEK_SET</tt> indicates positions
           relative to the beginning of the file, <tt>SEEK_CUR</tt> relative to
           the current position, <tt>SEEK_END</tt> relative to the end of the
           file. 
</dl>
<pre>
value lseek : file_descr -&gt; int -&gt; seek_command -&gt; int
</pre>
<dl><dd>
 Set the current position for a file descriptor 
</dl>
<pre>
value truncate : string -&gt; int -&gt; unit
</pre>
<dl><dd>
 Truncates the named file to the given size. 
</dl>
<pre>
value ftruncate : file_descr -&gt; int -&gt; unit
</pre>
<dl><dd>
 Truncates the file corresponding to the given descriptor
           to the given size. 
</dl>
<H3>File statistics </H3>
<pre>
type file_kind =
    S_REG                               (* Regular file *)
  | S_DIR                               (* Directory *)
  | S_CHR                               (* Character device *)
  | S_BLK                               (* Block device *)
  | S_LNK                               (* Symbolic link *)
  | S_FIFO                              (* Named pipe *)
  | S_SOCK                              (* Socket *)
type stats =
  { st_dev : int;                       (* Device number *)
    st_ino : int;                       (* Inode number *)
    st_kind : file_kind;                (* Kind of the file *)
    st_perm : file_perm;                (* Access rights *)
    st_nlink : int;                     (* Number of links *)
    st_uid : int;                       (* User id of the owner *)
    st_gid : int;                       (* Group id of the owner *)
    st_rdev : int;                      (* Device minor number *)
    st_size : int;                      (* Size in bytes *)
    st_atime : int;                     (* Last access time *)
    st_mtime : int;                     (* Last modification time *)
    st_ctime : int }                    (* Last status change time *)
</pre>
<dl><dd>
 The informations returned by the <tt>stat</tt> calls. 
</dl>
<pre>
value stat : string -&gt; stats
</pre>
<dl><dd>
 Return the information for the named file. 
</dl>
<pre>
value lstat : string -&gt; stats
</pre>
<dl><dd>
 Same as <tt>stat</tt>, but in case the file is a symbolic link,
           return the information for the link itself. 
</dl>
<pre>
value fstat : file_descr -&gt; stats
</pre>
<dl><dd>
 Return the information for the file associated with the given
           descriptor. 
</dl>
<H3>Operations on file names </H3>
<pre>
value unlink : string -&gt; unit
</pre>
<dl><dd>
 Removes the named file 
</dl>
<pre>
value rename : string -&gt; string -&gt; unit
</pre>
<dl><dd>
 <tt>rename old new</tt> changes the name of a file from <tt>old</tt> to <tt>new</tt>. 
</dl>
<pre>
value link : string -&gt; string -&gt; unit
</pre>
<dl><dd>
 <tt>link source dest</tt> creates a hard link named <tt>dest</tt> to the file
           named <tt>new</tt>. 
</dl>
<H3>File permissions and ownership </H3>
<pre>
type access_permission =
    R_OK                                (* Read permission *)
  | W_OK                                (* Write permission *)
  | X_OK                                (* Execution permission *)
  | F_OK                                (* File exists *)
</pre>
<dl><dd>
 Flags for the <tt>access</tt> call. 
</dl>
<pre>
value chmod : string -&gt; file_perm -&gt; unit
</pre>
<dl><dd>
 Change the permissions of the named file. 
</dl>
<pre>
value fchmod : file_descr -&gt; file_perm -&gt; unit
</pre>
<dl><dd>
 Change the permissions of an opened file. 
</dl>
<pre>
value chown : string -&gt; int -&gt; int -&gt; unit
</pre>
<dl><dd>
 Change the owner uid and owner gid of the named file. 
</dl>
<pre>
value fchown : file_descr -&gt; int -&gt; int -&gt; unit
</pre>
<dl><dd>
 Change the owner uid and owner gid of an opened file. 
</dl>
<pre>
value umask : int -&gt; int
</pre>
<dl><dd>
 Set the process creation mask, and return the previous mask. 
</dl>
<pre>
value access : string -&gt; access_permission list -&gt; unit
</pre>
<dl><dd>
 Check that the process has the given permissions over the named
           file. Raise <tt>Unix_error</tt> otherwise. 
</dl>
<H3>File descriptor hacking </H3>
<pre>
value fcntl_int : file_descr -&gt; int -&gt; int -&gt; int
</pre>
<dl><dd>
 Interface to <tt>fcntl</tt> in the case where the argument is an
           integer. The first integer argument is the command code;
           the second is the integer parameter. 
</dl>
<pre>
value fcntl_ptr : file_descr -&gt; int -&gt; string -&gt; int
</pre>
<dl><dd>
 Interface to <tt>fcntl</tt> in the case where the argument is a pointer.
           The integer argument is the command code. A pointer to the string
           argument is passed as argument to the command. 
</dl>
<H3>Directories </H3>
<pre>
value mkdir : string -&gt; file_perm -&gt; unit
</pre>
<dl><dd>
 Create a directory with the given permissions. 
</dl>
<pre>
value rmdir : string -&gt; unit
</pre>
<dl><dd>
 Remove an empty directory. 
</dl>
<pre>
value chdir : string -&gt; unit
</pre>
<dl><dd>
 Change the process working directory. 
</dl>
<pre>
value getcwd : unit -&gt; string
</pre>
<dl><dd>
 Return the name of the current working directory. 
</dl>
<pre>
type dir_handle
</pre>
<dl><dd>
 The type of descriptors over opened directories. 
</dl>
<pre>
value opendir : string -&gt; dir_handle
</pre>
<dl><dd>
 Open a descriptor on a directory 
</dl>
<pre>
value readdir : dir_handle -&gt; string
</pre>
<dl><dd>
 Return the next entry in a directory.
           Raise <tt>End_of_file</tt> when the end of the directory has been 
           reached. 
</dl>
<pre>
value rewinddir : dir_handle -&gt; unit
</pre>
<dl><dd>
 Reposition the descriptor to the beginning of the directory 
</dl>
<pre>
value closedir : dir_handle -&gt; unit
</pre>
<dl><dd>
 Close a directory descriptor. 
</dl>
<H3>Pipes and redirections </H3>
<pre>
value pipe : unit -&gt; file_descr * file_descr
</pre>
<dl><dd>
 Create a pipe. The first component of the result is opened
           for reading, that's the exit to the pipe. The second component is
           opened for writing, that's the entrace to the pipe. 
</dl>
<pre>
value dup : file_descr -&gt; file_descr
</pre>
<dl><dd>
 Duplicate a descriptor. 
</dl>
<pre>
value dup2 : file_descr -&gt; file_descr -&gt; unit
</pre>
<dl><dd>
 <tt>dup2 fd1 fd2</tt> duplicates <tt>fd1</tt> to <tt>fd2</tt>, closing <tt>fd2</tt> if already
           opened. 
</dl>
<pre>
value open_process_in: string -&gt; in_channel
value open_process_out: string -&gt; out_channel
value open_process: string -&gt; in_channel * out_channel
</pre>
<dl><dd>
 High-level pipe and process management. These functions
           run the given command in parallel with the program,
           and return channels connected to the standard input and/or
           the standard output of the command. The command is interpreted
           by the shell <tt>/bin/sh</tt> (cf. <tt>system</tt>). Warning: writes on channels
           are buffered, hence be careful to call <tt>flush</tt> at the right times
           to ensure correct synchronization. 
</dl>
<pre>
value close_process_in: in_channel -&gt; process_status
value close_process_out: out_channel -&gt; process_status
value close_process: in_channel * out_channel -&gt; process_status
</pre>
<dl><dd>
 Close channels opened by <tt>open_process_in</tt>, <tt>open_process_out</tt>
           and <tt>open_process</tt>, respectively, wait for the associated
           command to terminate, and return its termination status. 
</dl>
<H3>Symbolic links </H3>
<pre>
value symlink : string -&gt; string -&gt; unit
</pre>
<dl><dd>
 <tt>symlink source dest</tt> creates the file <tt>dest</tt> as a symbolic link
           to the file <tt>source</tt>. 
</dl>
<pre>
value readlink : string -&gt; string
</pre>
<dl><dd>
 Read the contents of a link. 
</dl>
<H3>Named pipes </H3>
<pre>
value mkfifo : string -&gt; file_perm -&gt; unit
</pre>
<dl><dd>
 Create a named pipe with the given permissions. 
</dl>
<H3>Special files </H3>
<pre>
value ioctl_int : file_descr -&gt; int -&gt; int -&gt; int
</pre>
<dl><dd>
 Interface to <tt>ioctl</tt> in the case where the argument is an
           integer. The first integer argument is the command code;
           the second is the integer parameter. 
</dl>
<pre>
value ioctl_ptr : file_descr -&gt; int -&gt; string -&gt; int
</pre>
<dl><dd>
 Interface to <tt>ioctl</tt> in the case where the argument is a pointer.
           The integer argument is the command code. A pointer to the string
           argument is passed as argument to the command. 
</dl>
<H3>Polling </H3>
<pre>
value select :
  file_descr list -&gt; file_descr list -&gt; file_descr list -&gt; float -&gt;
        file_descr list * file_descr list * file_descr list
</pre>
<dl><dd>
 Wait until some input/output operations become possible on
           some channels. The three list arguments are, respectively, a set
           of descriptors to check for reading (first argument), for writing
           (second argument), or for exceptional conditions (third argument).
           The fourth argument is the maximal timeout, in seconds; a
           negative fourth argument means no timeout (unbounded wait).
           The result is composed of three sets of descriptors: those ready
           for reading (first component), ready for writing (second component),
           and over which an exceptional condition is pending (third
           component). 
</dl>
<H3>Locking </H3>
<pre>
type lock_command =
    F_ULOCK               (* Unlock a region *)
  | F_LOCK                (* Lock a region, and block if already locked *)
  | F_TLOCK               (* Lock a region, or fail if already locked *)
  | F_TEST                (* Test a region for other process' locks *)
</pre>
<dl><dd>
 Commands for <tt>lockf</tt>. 
</dl>
<pre>
value lockf : file_descr -&gt; lock_command -&gt; int -&gt; unit
</pre>
<dl><dd>
 <tt>lockf fd cmd size</tt> puts a lock on a region of the file opened
           as <tt>fd</tt>. The region starts at the current read/write position for
           <tt>fd</tt> (as set by <tt>lseek</tt>), and extends <tt>size</tt> bytes forward if
           <tt>size</tt> is positive, <tt>size</tt> bytes backwards if <tt>size</tt> is negative,
           or to the end of the file if <tt>size</tt> is zero. 
</dl>
<H3>Signals </H3>
<pre>
type signal =
    SIGHUP              (* hangup *)
  | SIGINT              (* interrupt *)
  | SIGQUIT             (* quit *)
  | SIGILL              (* illegal instruction (not reset when caught) *)
  | SIGTRAP             (* trace trap (not reset when caught) *)
  | SIGABRT             (* used by abort *)
  | SIGEMT              (* EMT instruction *)
  | SIGFPE              (* floating point exception *)
  | SIGKILL             (* kill (cannot be caught or ignored) *)
  | SIGBUS              (* bus error *)
  | SIGSEGV             (* segmentation violation *)
  | SIGSYS              (* bad argument to system call *)
  | SIGPIPE             (* write on a pipe with no one to read it *)
  | SIGALRM             (* alarm clock *)
  | SIGTERM             (* software termination signal from kill *)
  | SIGURG              (* urgent condition on IO channel *)
  | SIGSTOP             (* sendable stop signal not from tty *)
  | SIGTSTP             (* stop signal from tty *)
  | SIGCONT             (* continue a stopped process *)
  | SIGCHLD             (* to parent on child stop or exit *)
  | SIGIO               (* input/output possible signal *)
  | SIGXCPU             (* exceeded CPU time limit *)
  | SIGXFSZ             (* exceeded file size limit *)
  | SIGVTALRM           (* virtual time alarm *)
  | SIGPROF             (* profiling time alarm *)
  | SIGWINCH            (* window changed *)
  | SIGLOST             (* resource lost (eg, record-lock lost) *)
  | SIGUSR1             (* user defined signal 1 *)
  | SIGUSR2             (* user defined signal 2 *)
</pre>
<dl><dd>
 The type of signals. 
</dl>
<pre>
type signal_handler =
    Signal_default                      (* Default behavior for the signal *)
  | Signal_ignore                       (* Ignore the signal *)
  | Signal_handle of (unit -&gt; unit)     (* Call the given function
                                           when the signal occurs. *)
</pre>
<dl><dd>
 The behavior on receipt of a signal 
</dl>
<pre>
value kill : int -&gt; signal -&gt; unit
</pre>
<dl><dd>
 Send a signal to the process with the given process id. 
</dl>
<pre>
value signal : signal -&gt; signal_handler -&gt; unit
</pre>
<dl><dd>
 Set the behavior to be taken on receipt of the given signal. 
</dl>
<pre>
value pause : unit -&gt; unit
</pre>
<dl><dd>
 Wait until a non-ignored signal is delivered. 
</dl>
<H3>Time functions </H3>
<pre>
type process_times =
  { tms_utime : float;          (* User time for the process *)
    tms_stime : float;          (* System time for the process *)
    tms_cutime : float;         (* User time for the children processes *)
    tms_cstime : float }        (* System time for the children processes *)
</pre>
<dl><dd>
 The execution times (CPU times) of a process. 
</dl>
<pre>
type tm =
  { tm_sec : int;                       (* Seconds 0..59 *)
    tm_min : int;                       (* Minutes 0..59 *)
    tm_hour : int;                      (* Hours 0..23 *)
    tm_mday : int;                      (* Day of month 1..31 *)
    tm_mon : int;                       (* Month of year 0..11 *)
    tm_year : int;                      (* Year - 1900 *)
    tm_wday : int;                      (* Day of week (Sunday is 0) *)
    tm_yday : int;                      (* Day of year 0..365 *)
    tm_isdst : bool }                   (* Daylight time savings in effect *)
</pre>
<dl><dd>
 The type representing wallclock time and calendar date. 
</dl>
<pre>
value time : unit -&gt; int
</pre>
<dl><dd>
 Return the current time since 00:00:00 GMT, Jan. 1, 1970,
           in seconds. 
</dl>
<pre>
value gettimeofday : unit -&gt; float
</pre>
<dl><dd>
 Same as <tt>time</tt>, but with resolution better than 1 second. 
</dl>
<pre>
value gmtime : int -&gt; tm
</pre>
<dl><dd>
 Convert a time in seconds, as returned by <tt>time</tt>, into a date and
           a time. Assumes Greenwich meridian time zone. 
</dl>
<pre>
value localtime : int -&gt; tm
</pre>
<dl><dd>
 Convert a time in seconds, as returned by <tt>time</tt>, into a date and
           a time. Assumes the local time zone. 
</dl>
<pre>
value alarm : int -&gt; int
</pre>
<dl><dd>
 Schedule a <tt>SIGALRM</tt> signals after the given number of seconds. 
</dl>
<pre>
value sleep : int -&gt; unit
</pre>
<dl><dd>
 Stop execution for the given number of seconds. 
</dl>
<pre>
value times : unit -&gt; process_times
</pre>
<dl><dd>
 Return the execution times of the process. 
</dl>
<pre>
value utimes : string -&gt; int -&gt; int -&gt; unit
</pre>
<dl><dd>
 Set the last access time (second arg) and last modification time
           (third arg) for a file. Times are expressed in seconds from
           00:00:00 GMT, Jan. 1, 1970. 
</dl>
<H3>User id, group id </H3>
<pre>
value getuid : unit -&gt; int
</pre>
<dl><dd>
 Return the user id of the user executing the process. 
</dl>
<pre>
value geteuid : unit -&gt; int
</pre>
<dl><dd>
 Return the effective user id under which the process runs. 
</dl>
<pre>
value setuid : int -&gt; unit
</pre>
<dl><dd>
 Set the real user id and effective user id for the process. 
</dl>
<pre>
value getgid : unit -&gt; int
</pre>
<dl><dd>
 Return the group id of the user executing the process. 
</dl>
<pre>
value getegid : unit -&gt; int
</pre>
<dl><dd>
 Return the effective group id under which the process runs. 
</dl>
<pre>
value setgid : int -&gt; unit
</pre>
<dl><dd>
 Set the real group id and effective group id for the process. 
</dl>
<pre>
value getgroups : unit -&gt; int vect
</pre>
<dl><dd>
 Return the list of groups to which the user executing the process
           belongs. 
</dl>
<pre>
type passwd_entry =
  { pw_name : string;
    pw_passwd : string;
    pw_uid : int;
    pw_gid : int;
    pw_gecos : string;
    pw_dir : string;
    pw_shell : string }
</pre>
<dl><dd>
 Structure of entries in the <tt>passwd</tt> database. 
</dl>
<pre>
type group_entry =
  { gr_name : string;
    gr_passwd : string;
    gr_gid : int;
    gr_mem : string vect }
</pre>
<dl><dd>
 Structure of entries in the <tt>groups</tt> database. 
</dl>
<pre>
value getlogin : unit -&gt; string
</pre>
<dl><dd>
 Return the login name of the user executing the process. 
</dl>
<pre>
value getpwnam : string -&gt; passwd_entry
</pre>
<dl><dd>
 Find an entry in <tt>passwd</tt> with the given name, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getgrnam : string -&gt; group_entry
</pre>
<dl><dd>
 Find an entry in <tt>group</tt> with the given name, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getpwuid : int -&gt; passwd_entry
</pre>
<dl><dd>
 Find an entry in <tt>passwd</tt> with the given user id, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getgrgid : int -&gt; group_entry
</pre>
<dl><dd>
 Find an entry in <tt>group</tt> with the given group id, or raise
           <tt>Not_found</tt>. 
</dl>
<H3>Internet addresses </H3>
<pre>
type inet_addr
</pre>
<dl><dd>
 The abstract type of Internet addresses. 
</dl>
<pre>
value inet_addr_of_string : string -&gt; inet_addr
value string_of_inet_addr : inet_addr -&gt; string
</pre>
<dl><dd>
 Conversions between string with the format <tt>XXX.YYY.ZZZ.TTT</tt>
           and Internet addresses. <tt>inet_addr_of_string</tt> raises <tt>Failure</tt>
           when given a string that does not match this format. 
</dl>
<H3>Sockets </H3>
<pre>
type socket_domain =
    PF_UNIX                             (* Unix domain *)
  | PF_INET                             (* Internet domain *)
</pre>
<dl><dd>
 The type of socket domains. 
</dl>
<pre>
type socket_type =
    SOCK_STREAM                         (* Stream socket *)
  | SOCK_DGRAM                          (* Datagram socket *)
  | SOCK_RAW                            (* Raw socket *)
  | SOCK_SEQPACKET                      (* Sequenced packets socket *)
</pre>
<dl><dd>
 The type of socket kinds, specifying the semantics of
           communications. 
</dl>
<pre>
type sockaddr =
    ADDR_UNIX of string
  | ADDR_INET of inet_addr * int
</pre>
<dl><dd>
 The type of socket addresses. <tt>ADDR_UNIX name</tt> is a socket
           address in the Unix domain; <tt>name</tt> is a file name in the file
           system. <tt>ADDR_INET(addr,port)</tt> is a socket address in the Internet
           domain; <tt>addr</tt> is the Internet address of the machine, and
           <tt>port</tt> is the port number. 
</dl>
<pre>
type shutdown_command =
    SHUTDOWN_RECEIVE                    (* Close for receiving *)
  | SHUTDOWN_SEND                       (* Close for sending *)
  | SHUTDOWN_ALL                        (* Close both *)
</pre>
<dl><dd>
 The type of commands for <tt>shutdown</tt>. 
</dl>
<pre>
type msg_flag =
    MSG_OOB
  | MSG_DONTROUTE
  | MSG_PEEK
</pre>
<dl><dd>
 The flags for <tt>recv</tt>, <tt>recvfrom</tt>, <tt>send</tt> and <tt>sendto</tt>. 
</dl>
<pre>
value socket : socket_domain -&gt; socket_type -&gt; int -&gt; file_descr
</pre>
<dl><dd>
 Create a new socket in the given domain, and with the
           given kind. The third argument is the protocol type; 0 selects
           the default protocol for that kind of sockets. 
</dl>
<pre>
value socketpair :
        socket_domain -&gt; socket_type -&gt; int -&gt; file_descr * file_descr
</pre>
<dl><dd>
 Create a pair of unnamed sockets, connected together. 
</dl>
<pre>
value accept : file_descr -&gt; file_descr * sockaddr
</pre>
<dl><dd>
 Accept connections on the given socket. The returned descriptor
           is a socket connected to the client; the returned address is
           the address of the connecting client. 
</dl>
<pre>
value bind : file_descr -&gt; sockaddr -&gt; unit
</pre>
<dl><dd>
 Bind a socket to an address. 
</dl>
<pre>
value connect : file_descr -&gt; sockaddr -&gt; unit
</pre>
<dl><dd>
 Connect a socket to an address. 
</dl>
<pre>
value listen : file_descr -&gt; int -&gt; unit
</pre>
<dl><dd>
 Set up a socket for receiving connection requests. The integer
           argument is the maximal number of pending requests. 
</dl>
<pre>
value shutdown : file_descr -&gt; shutdown_command -&gt; unit
</pre>
<dl><dd>
 Shutdown a socket connection. <tt>SHUTDOWN_SEND</tt> as second argument
           causes reads on the other end of the connection to return
           an end-of-file condition.
           <tt>SHUTDOWN_RECEIVE</tt> causes writes on the other end of the connection
           to return a closed pipe condition (<tt>SIGPIPE</tt> signal). 
</dl>
<pre>
value getsockname : file_descr -&gt; sockaddr
</pre>
<dl><dd>
 Return the address of the given socket. 
</dl>
<pre>
value getpeername : file_descr -&gt; sockaddr
</pre>
<dl><dd>
 Return the address of the host connected to the given socket. 
</dl>
<pre>
value recv : file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int
value recvfrom :
        file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int * sockaddr
</pre>
<dl><dd>
 Receive data from an unconnected socket. 
</dl>
<pre>
value send : file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int
value sendto :
        file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; sockaddr -&gt; int
</pre>
<dl><dd>
 Send data over an unconnected socket. 
</dl>
<H3>High-level network connection functions </H3>
<pre>
value open_connection : sockaddr -&gt; in_channel * out_channel
</pre>
<dl><dd>
 Connect to a server at the given address.
           Return a pair of buffered channels connected to the server.
           Remember to call <tt>flush</tt> on the output channel at the right times
           to ensure correct synchronization. 
</dl>
<pre>
value shutdown_connection : in_channel -&gt; unit
</pre>
<dl><dd>
 ``Shut down'' a connection established with <tt>open_connection</tt>;
           that is, transmit an end-of-file condition to the server reading
           on the other side of the connection. 
</dl>
<pre>
value establish_server : (in_channel -&gt; out_channel -&gt; unit) -&gt; sockaddr -&gt; unit
</pre>
<dl><dd>
 Establish a server on the given address.
           The function given as first argument is called for each connection
           with two buffered channels connected to the client. A new process
           is created for each connection. The function <tt>establish_server</tt>
           never returns normally. 
</dl>
<H3>Host and protocol databases </H3>
<pre>
type host_entry =
  { h_name : string;
    h_aliases : string vect;
    h_addrtype : socket_domain;
    h_addr_list : inet_addr vect }
</pre>
<dl><dd>
 Structure of entries in the <tt>hosts</tt> database. 
</dl>
<pre>
type protocol_entry =
  { p_name : string;
    p_aliases : string vect;
    p_proto : int }
</pre>
<dl><dd>
 Structure of entries in the <tt>protocols</tt> database. 
</dl>
<pre>
type service_entry =
  { s_name : string;
    s_aliases : string vect;
    s_port : int;
    s_proto : string }
</pre>
<dl><dd>
 Structure of entries in the <tt>services</tt> database. 
</dl>
<pre>
value gethostname : unit -&gt; string
</pre>
<dl><dd>
 Return the name of the local host. 
</dl>
<pre>
value gethostbyname : string -&gt; host_entry
</pre>
<dl><dd>
 Find an entry in <tt>hosts</tt> with the given name, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value gethostbyaddr : inet_addr -&gt; host_entry
</pre>
<dl><dd>
 Find an entry in <tt>hosts</tt> with the given address, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getprotobyname : string -&gt; protocol_entry
</pre>
<dl><dd>
 Find an entry in <tt>protocols</tt> with the given name, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getprotobynumber : int -&gt; protocol_entry
</pre>
<dl><dd>
 Find an entry in <tt>protocols</tt> with the given protocol number,
           or raise <tt>Not_found</tt>. 
</dl>
<pre>
value getservbyname : string -&gt; string -&gt; service_entry
</pre>
<dl><dd>
 Find an entry in <tt>services</tt> with the given name, or raise
           <tt>Not_found</tt>. 
</dl>
<pre>
value getservbyport : int -&gt; string -&gt; service_entry
</pre>
<dl><dd>
 Find an entry in <tt>services</tt> with the given service number,
           or raise <tt>Not_found</tt>. 
</dl>
<H3>Terminal interface </H3>
<dl><dd>
 The following functions implement the POSIX standard terminal
   interface. They provide control over asynchronous communication ports
   and pseudo-terminals. Refer to the <tt>termios</tt> man page for a
   complete description. 
</dl>
<pre>
type terminal_io = {
</pre>
<dl><dd>
 Input modes: 
</dl>
<pre>
    mutable c_ignbrk: bool;  (* Ignore the break condition. *)
    mutable c_brkint: bool;  (* Signal interrupt on break condition. *)
    mutable c_ignpar: bool;  (* Ignore characters with parity errors. *)
    mutable c_parmrk: bool;  (* Mark parity errors. *)
    mutable c_inpck: bool;   (* Enable parity check on input. *)
    mutable c_istrip: bool;  (* Strip 8th bit on input characters. *)
    mutable c_inlcr: bool;   (* Map NL to CR on input. *)
    mutable c_igncr: bool;   (* Ignore CR on input. *)
    mutable c_icrnl: bool;   (* Map CR to NL on input. *)
    mutable c_ixon: bool;    (* Recognize XON/XOFF characters on input. *)
    mutable c_ixoff: bool;   (* Emit XON/XOFF chars to control input flow. *)
</pre>
<dl><dd>
 Output modes: 
</dl>
<pre>
    mutable c_opost: bool;   (* Enable output processing. *)
</pre>
<dl><dd>
 Control modes: 
</dl>
<pre>
    mutable c_obaud: int;    (* Output baud rate (0 means close connection).*)
    mutable c_ibaud: int;    (* Input baud rate. *)
    mutable c_csize: int;    (* Number of bits per character (5-8). *)
    mutable c_cstopb: int;   (* Number of stop bits (1-2). *)
    mutable c_cread: bool;   (* Reception is enabled. *)
    mutable c_parenb: bool;  (* Enable parity generation and detection. *)
    mutable c_parodd: bool;  (* Specify odd parity instead of even. *)
    mutable c_hupcl: bool;   (* Hang up on last close. *)
    mutable c_clocal: bool;  (* Ignore modem status lines. *)
</pre>
<dl><dd>
 Local modes: 
</dl>
<pre>
    mutable c_isig: bool;    (* Generate signal on INTR, QUIT, SUSP. *)
    mutable c_icanon: bool;  (* Enable canonical processing
                                (line buffering and editing) *)
    mutable c_noflsh: bool;  (* Disable flush after INTR, QUIT, SUSP. *)
    mutable c_echo: bool;    (* Echo input characters. *)
    mutable c_echoe: bool;   (* Echo ERASE (to erase previous character). *)
    mutable c_echok: bool;   (* Echo KILL (to erase the current line). *)
    mutable c_echonl: bool;  (* Echo NL even if c_echo is not set. *)
</pre>
<dl><dd>
 Control characters: 
</dl>
<pre>
    mutable c_vintr: char;   (* Interrupt character (usually ctrl-C). *)
    mutable c_vquit: char;   (* Quit character (usually ctrl-\). *)
    mutable c_verase: char;  (* Erase character (usually DEL or ctrl-H). *)
    mutable c_vkill: char;   (* Kill line character (usually ctrl-U). *)
    mutable c_veof: char;    (* End-of-file character (usually ctrl-D). *)
    mutable c_veol: char;    (* Alternate end-of-line char. (usually none). *)
    mutable c_vmin: int;     (* Minimum number of characters to read
                                before the read request is satisfied. *)
    mutable c_vtime: int;    (* Maximum read wait (in 0.1s units). *)
    mutable c_vstart: char;  (* Start character (usually ctrl-Q). *)
    mutable c_vstop: char    (* Stop character (usually ctrl-S). *)
  }
value tcgetattr: file_descr -&gt; terminal_io
</pre>
<dl><dd>
 Return the status of the terminal referred to by the given
           file descriptor. 
</dl>
<pre>
type setattr_when = TCSANOW | TCSADRAIN | TCSAFLUSH
value tcsetattr: file_descr -&gt; setattr_when -&gt; terminal_io -&gt; unit
</pre>
<dl><dd>
 Set the status of the terminal referred to by the given
           file descriptor. The second argument indicates when the
           status change takes place: immediately (<tt>TCSANOW</tt>),
           when all pending output has been transmitted (<tt>TCSADRAIN</tt>),
           or after flushing all input that has been received but not
           read (<tt>TCSAFLUSH</tt>). <tt>TCSADRAIN</tt> is recommended when changing
           the output parameters; <tt>TCSAFLUSH</tt>, when changing the input
           parameters. 
</dl>
<pre>
value tcsendbreak: file_descr -&gt; int -&gt; unit
</pre>
<dl><dd>
 Send a break condition on the given file descriptor.
           The second argument is the duration of the break, in 0.1s units;
           0 means standard duration (0.25s). 
</dl>
<pre>
value tcdrain: file_descr -&gt; unit
</pre>
<dl><dd>
 Waits until all output written on the given file descriptor
           has been transmitted. 
</dl>
<pre>
type flush_queue = TCIFLUSH | TCOFLUSH | TCIOFLUSH
value tcflush: file_descr -&gt; flush_queue -&gt; unit
</pre>
<dl><dd>
 Discard data written on the given file descriptor but not yet
           transmitted, or data received but not yet read, depending on the
           second argument: <tt>TCIFLUSH</tt> flushes data received but not read,
           <tt>TCOFLUSH</tt> flushes data written but not transmitted, and
           <tt>TCIOFLUSH</tt> flushes both. 
</dl>
<pre>
type flow_action = TCOOFF | TCOON | TCIOFF | TCION
value tcflow: file_descr -&gt; flow_action -&gt; unit
</pre>
<dl><dd>
 Suspend or restart reception or transmission of data on
           the given file descriptor, depending on the second argument:
           <tt>TCOOFF</tt> suspends output, <tt>TCOON</tt> restarts output,
           <tt>TCIOFF</tt> transmits a STOP character to suspend input,
           and <tt>TCION</tt> transmits a START character to restart input. 
</dl>
<P>
<HR>
<A HREF="node18.html"><IMG SRC="next_motif.gif"></A>
<A HREF="node16.html"><IMG SRC="previous_motif.gif"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif"></A>
