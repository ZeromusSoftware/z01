<HEAD>
<TITLE>Batch compilation (camlc)</TITLE>
</HEAD>
<BODY>
<A HREF="node6.html"><IMG SRC="next_motif.gif"></A>
<A HREF="node4.10.html"><IMG SRC="previous_motif.gif"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif"></A>
<HR>
<H1>Batch compilation (camlc)</H1>
 <A name="c:camlc"></A><P>
This chapter describes how Caml Light programs can be compiled
non-interactively, and turned into standalone executable files. This
is achieved by the command <tt>camlc</tt>, which compiles and links Caml
Light source files. <P>
<dl><dt><b>Mac:</b><dd> This command is not a standalone Macintosh application.
To run <tt>camlc</tt>, you need the Macintosh Programmer's Workshop (MPW)
programming environment. The programs generated by <tt>camlc</tt> are also
MPW tools, not standalone Macintosh applications.
</dl><P>
<H2>Overview of the compiler</H2>
<P>
The <tt>camlc</tt> command has a command-line interface similar to the one of
most C compilers. It accepts several types of arguments: source files
for module implementations; source files for module interfaces; and
compiled module implementations.<P>
<p><ul>
<li>
Arguments ending in <tt>.mli</tt> are taken to be source files for module
interfaces. Module interfaces declare exported global identifiers,
define public data types, and so on. From the file <i>x</i><tt>.mli</tt>, the <tt>camlc</tt>
compiler produces a compiled interface in the file <i>x</i><tt>.zi</tt>.<P>
<li>
Arguments ending in <tt>.ml</tt> are taken to be source files for module
implementation. Module implementations bind global identifiers to
values, define private data types, and contain expressions to be
evaluated for their side-effects.  From the file <i>x</i><tt>.ml</tt>, the <tt>camlc</tt>
compiler produces compiled object code in the file <i>x</i><tt>.zo</tt>. If
the interface file <i>x</i><tt>.mli</tt> exists, the module implementation <i>x</i><tt>.ml</tt>
is checked against the corresponding compiled interface <i>x</i><tt>.zi</tt>,
which is assumed to exist. If no interface <i>x</i><tt>.mli</tt> is provided, the
compilation of <i>x</i><tt>.ml</tt> produces a compiled interface file <i>x</i><tt>.zi</tt> in
addition to the compiled object code file <i>x</i><tt>.zo</tt>. The
file <i>x</i><tt>.zi</tt> produced corresponds to an interface that exports
everything that is defined in the implementation <i>x</i><tt>.ml</tt>.<P>
<li>
Arguments ending in <tt>.zo</tt> are taken to be compiled object code.  These
files are linked together, along with the object code files obtained
by compiling <tt>.ml</tt> arguments (if any), and the Caml Light standard
library, to produce a standalone executable program. The order in
which <tt>.zo</tt> and <tt>.ml</tt> arguments are presented on the command line is
relevant: global identifiers are initialized in that order at
run-time, and it is a link-time error to use a global identifier
before having initialized it. Hence, a given <i>x</i><tt>.zo</tt> file must come
before all <tt>.zo</tt> files that refer to identifiers defined in the file
<i>x</i><tt>.zo</tt>.<P>
</ul><P>
The output of the linking phase is a file containing compiled code
that can be executed by the Caml Light runtime system: the
command named <tt>camlrun</tt>. If <tt>caml.out</tt> is the name of the file
produced by the linking phase, the command
<pre>
        camlrun caml.out <i>arg</i><sub>1</sub> <i>arg</i><sub>2</sub> ... <i>arg</i><sub>n</sub>
</pre>
executes the compiled code contained in <tt>caml.out</tt>, passing it as
arguments the character strings <i>arg</i><sub>1</sub> to <i>arg</i><sub>n</sub>.
(See chapter <A HREF="node7.html#c:runtime">7</A> for more details.)<P>
<dl><dt><b>Unix:</b><dd> On most Unix systems, the file produced by the linking
phase can be run directly, as in:
<pre>
        ./caml.out <i>arg</i><sub>1</sub> <i>arg</i><sub>2</sub> ... <i>arg</i><sub>n</sub>
</pre>
The produced file has the executable bit set, and it manages to launch
the bytecode interpreter by itself.
</dl><P>
<dl><dt><b>PC:</b><dd> The output file produced by the linking phase is directly
executable, provided it is given extension <tt>.EXE</tt>. Hence, if the
output file is named <tt>caml_out.exe</tt>, you can execute it with the
command
<pre>
        caml_out <i>arg</i><sub>1</sub> <i>arg</i><sub>2</sub> ... <i>arg</i><sub>n</sub>
</pre>
Actually, the produced file <tt>caml_out.exe</tt> is a tiny executable
file prepended to the bytecode file. The executable simply runs the
<tt>camlrun</tt> runtime system on the remainder of the file. (As a
consequence, this is not a standalone executable: it still requires
<tt>camlrun.exe</tt> to reside in one of the directories in the path.)
</dl><P>
<H2>Options</H2>
<P>
The following command-line options are recognized by <tt>camlc</tt>.<P>
<p><dl><P>
<dt><tt>-c</tt><dd>
Compile only. Suppress the linking phase of the
compilation. Source code files are turned into compiled files, but no
executable file is produced. This option is useful to
compile modules separately.<P>
<dt><tt>-ccopt</tt> <i>option</i><dd>
Pass the given option to the C compiler and linker, when linking in
``custom runtime'' mode (see the <tt>-custom</tt> option). For instance,
<tt>-ccopt -L</tt><i>dir</i> causes the C linker to search for C libraries in
directory <i>dir</i>.<P>
<dt><tt>-custom</tt><dd>
Link in ``custom runtime'' mode. In the default linking mode, the
linker produces bytecode that is intended to be executed with the
shared runtime system, <tt>camlrun</tt>. In the custom runtime mode, the
linker produces an output file that contains both the runtime system
and the bytecode for the program. The resulting file is considerably
larger, but it can be executed directly, even if the <tt>camlrun</tt> command
is not installed. Moreover, the ``custom runtime'' mode enables
linking Caml Light code with user-defined C functions, as described in
chapter <A HREF="node13.html#c:intf-c">13</A>.<P>
<dl><dt><b>Unix:</b><dd> Never strip an executable produced with the <tt>-custom</tt>
option.
</dl><P>
<dl><dt><b>PC:</b><dd> This option requires the <tt>DJGPP</tt> port of the GNU C compiler
to be installed.
</dl><P>
<dt><tt>-g</tt><dd>
Cause the compiler to produce additional debugging information.
During the linking phase, this option add information at the end of
the executable bytecode file produced. This information is required 
by the debugger <tt>camldebug</tt> and also by the catch-all exception
handler from the standard library module <tt>printexc</tt>.<P>
During the compilation of an implementation file (<tt>.ml</tt> file),  when
the <tt>-g</tt> option is set, the compiler adds debugging information to the
<tt>.zo</tt> file. It also writes a <tt>.zix</tt> file that describes the full
interface of the <tt>.ml</tt> file, that is, all types and values defined in
the <tt>.ml</tt> file, including those that are local to the <tt>.ml</tt> file
(i.e. not declared in the <tt>.mli</tt> interface file). Used in conjunction
with the <tt>-g</tt> option to the toplevel system
(chapter <A HREF="node6.html#c:camllight">6</A>), the <tt>.zix</tt> file gives access to the local
values of the module, making it possible to print or ``trace'' them.
The <tt>.zix</tt> file is not produced if the implementation file has no
explicit interface, since, in this case, the module has no local
values.<P>
<dt><tt>-i</tt><dd>
Cause the compiler to print the declared types, exceptions, and global
variables (with their inferred types) when compiling an implementation
(<tt>.ml</tt> file). This can be useful to check the types inferred by the
compiler. Also, since the output follows the syntax of module
interfaces, it can help in writing an explicit interface (<tt>.mli</tt> file)
for a file: just redirect the standard output of the compiler to a
<tt>.mli</tt> file, and edit that file to remove all declarations of
unexported globals.<P>
<dt><tt>-I</tt> <i>directory</i><dd>
Add the given directory to the list of directories searched for
compiled interface files (<tt>.zi</tt>) and compiled object code files
(<tt>.zo</tt>). By default, the current directory is searched first, then the
standard library directory. Directories added with <tt>-I</tt> are searched
after the current directory, but before the standard library
directory. When several directories are added with several <tt>-I</tt>
options on the command line, these directories are searched from right
to left (the rightmost directory is searched first, the leftmost is
searched last). (Directories can also be added to the search path from
inside the programs with the <tt>#directory</tt> directive; see
chapter <A HREF="node4.html#c:extensions">4</A>.)<P>
<dt><tt>-lang</tt> <i>language-code</i><dd>
Translate the compiler messages to the specified language.
The <i>language-code</i> is <tt>fr</tt> for French, <tt>es</tt> for Spanish, <tt>de</tt> for
German, ... (See the file <tt>camlmsgs.txt</tt> in the Caml Light
standard library directory for a list of available languages.)
When an unknown language is specified, or no translation is available
for a message, American English is used by default.<P>
<dt><tt>-o</tt> <i>exec-file</i><dd>
Specify the name of the output file produced by the linker.<P>
<dl><dt><b>Unix:</b><dd> The default output name is <tt>a.out</tt>, in keeping with the
tradition.
</dl><P>
<dl><dt><b>PC:</b><dd> The default output name is <tt>caml_out.exe</tt>. </dl><P>
<dl><dt><b>Mac:</b><dd> The default output name is <tt>Caml.Out</tt>. </dl><P>
<dt><tt>-O</tt> <i>module-set</i><dd>
Specify which set of standard modules is to be implicitly ``opened''
at the beginning of a compilation. There are three module sets
currently available:
<p><dl>
<dt>cautious<dd> provides the standard operations on integers,
floating-point numbers, characters, strings, arrays, ..., as well
as exception handling, basic input/output, etc. Operations from the
<tt>cautious</tt> set perform range and bound checking on string and array
operations, as well as various sanity checks on their arguments. 
<dt>fast<dd> provides the same operations as the <tt>cautious</tt> set, but
without sanity checks on their arguments. Programs compiled with
<tt>-O fast</tt> are therefore slightly faster, but unsafe.
<dt>none<dd> suppresses all automatic opening of modules. Compilation
starts in an almost empty environment. This option is not of general
use, except to compile the standard library itself.
</dl>
The default compilation mode is <tt>-O cautious</tt>. See
chapter <A HREF="node14.html#c:stdlib">14</A> for a complete listing of the modules in the
<tt>cautious</tt> and <tt>fast</tt> sets.<P>
<dt><tt>-p</tt><dd>
Compile and link in profiling mode. See the description of the
profiler <tt>camlpro</tt> in chapter <A HREF="node11.html#c:profiler">11</A>.<P>
<dt><tt>-v</tt><dd>
Print the version number of the compiler.<P>
<dt><tt>-W</tt><dd>
Print extra warning messages for the following events:
<p><ul>
<li> A <tt>#open</tt> directive is useless (no identifier in the opened
module is ever referenced).
<li> A variable name in a pattern matching is capitalized (often
corresponds to a misspelled constant constructor).
</ul><P>
</dl><P>
<dl><dt><b>Unix:</b><dd> The following environment variable is also consulted:
<p><dl>
<dt><tt>LANG</tt><dd> When set, control which language is used to print the
compiler messages (see the <tt>-lang</tt> command-line option).
</dl>
</dl><P>
<dl><dt><b>PC:</b><dd> The following option is also supported:
<p><dl>
<dt><tt>@</tt><i>response-file</i><dd>
Process the files whose names are listed in file
<i>response-file</i>, just as if these names appeared on the command line.
File names in <i>response-file</i> are separated by blanks (spaces,
tabs, newlines). This option allows to overcome silly limitations on
the length of the command line.
</dl>
The following environment variables are also consulted:
<p><dl>
<dt><tt>CAMLLIB</tt><dd> Contain the path to the standard library directory.<P>
<dt><tt>LANG</tt><dd> When set, control which language is used to print the
compiler messages (see the <tt>-lang</tt> command-line option).
</dl>
</dl><P>
<H2>Modules and the file system</H2>
<P>
This short section is intended to clarify the relationship between the
names of the modules and the names of the files that contain their
compiled interface and compiled implementation.<P>
The compiler always derives the name of the compiled module by taking
the base name of the source file (<tt>.ml</tt> or <tt>.mli</tt> file). That is, it
strips the leading directory name, if any, as well as the <tt>.ml</tt> or
<tt>.mli</tt> suffix. The produced <tt>.zi</tt> and <tt>.zo</tt> files have the same base
name as the source file; hence, the compiled files produced by the
compiler always have their base name equal to the name of the module
they describe (for <tt>.zi</tt> files) or implement (for <tt>.zo</tt> files).<P>
For compiled interface files (<tt>.zi</tt> files), this invariant must be
preserved at all times, since the compiler relies on it to load the
compiled interface file for the modules that are used from the module
being compiled. Hence, it is risky and generally incorrect to rename
<tt>.zi</tt> files. It is admissible to move them to another directory, if
their base name is preserved, and the correct <tt>-I</tt> options are given to
the compiler.<P>
Compiled bytecode files (<tt>.zo</tt> files), on the other hand, can be
freely renamed once created. That's because 1- <tt>.zo</tt> files contain the
true name of the module they define, so there is no need to derive
that name from the file name; 2- the linker never attempts to find by
itself the <tt>.zo</tt> file that implements a module of a given name: it
relies on the user providing the list of <tt>.zo</tt> files by hand.<P>
<H2>Common errors</H2>
 <A name="s:comp-errors"></A><P>
This section describes and explains the most frequently encountered
error messages.<P>
<p><dl><P>
<dt>Cannot find file <i>filename</i><dd>
The named file could not be found in the current directory, nor in the
directories of the search path. The <i>filename</i> is either a
compiled interface file (<tt>.zi</tt> file), or a compiled bytecode file
(<tt>.zo</tt> file). If <i>filename</i> has the format <i>mod</i><tt>.zi</tt>, this
means you are trying to compile a file that references identifiers
from module <i>mod</i>, but you have not yet compiled an interface for
module <i>mod</i>. Fix: compile <i>mod</i><tt>.mli</tt> or <i>mod</i><tt>.ml</tt>
first, to create the compiled interface <i>mod</i><tt>.zi</tt>. <P>
If <i>filename</i> has the format <i>mod</i><tt>.zo</tt>, this
means you are trying to link a bytecode object file that does not
exist yet. Fix: compile <i>mod</i><tt>.ml</tt> first.<P>
If your program spans several directories, this error can also appear
because you haven't specified the directories to look into. Fix: add
the correct <tt>-I</tt> options to the command line.<P>
<dt>Corrupted compiled interface file <i>filename</i><dd>
The compiler produces this error when it tries to read a compiled
interface file (<tt>.zi</tt> file) that has the wrong structure. This means
something went wrong when this <tt>.zi</tt> file was written: the disk was
full, the compiler was interrupted in the middle of the file creation,
and so on. This error can also appear if a <tt>.zi</tt> file is modified after
its creation by the compiler. Fix: remove the corrupted <tt>.zi</tt> file,
and rebuild it.<P>
<dt>This expression has type <i>t</i><sub>1</sub>, but is used with type <i>t</i><sub>2</sub><dd>
This is by far the most common type error in programs. Type <i>t</i><sub>1</sub> is
the type inferred for the expression (the part of the program that is
displayed in the error message), by looking at the expression itself.
Type <i>t</i><sub>2</sub> is the type expected by the context of the expression; it
is deduced by looking at how the value of this expression is used in
the rest of the program. If the two types <i>t</i><sub>1</sub> and <i>t</i><sub>2</sub> are not
compatible, then the error above is produced.<P>
In some cases, it is hard to understand why the two types <i>t</i><sub>1</sub> and
<i>t</i><sub>2</sub> are incompatible. For instance, the compiler can report that
``expression of type <tt>foo</tt> cannot be used with type <tt>foo</tt>'', and it
really seems that the two types <tt>foo</tt> are compatible. This is not
always true. Two type constructors can have the same name, but
actually represent different types. This can happen if a type
constructor is redefined. Example:
<pre>
        type foo = A | B;;
        let f = function A -&gt; 0 | B -&gt; 1;;
        type foo = C | D;;
        f C;;
</pre>
This result in the error message ``expression <tt>C</tt> of type <tt>foo</tt> cannot
be used with type <tt>foo</tt>''. <P>
Incompatible types with the same names can also appear when a module
is changed and recompiled, but some of its clients are not recompiled.
That's because type constructors in <tt>.zi</tt> files are not represented by
their name (that would not suffice to identify them, because of type
redefinitions), but by unique stamps that are assigned when the type
declaration is compiled. Consider the three modules:
<pre>
        mod1.ml:    type t = A | B;;
                    let f = function A -&gt; 0 | B -&gt; 1;;

        mod2.ml:    let g x = 1 + mod1__f(x);;

        mod3.ml:    mod2__g mod1__A;;
</pre>
Now, assume <tt>mod1.ml</tt> is changed and recompiled, but <tt>mod2.ml</tt> is not
recompiled. The recompilation of <tt>mod1.ml</tt> can change the stamp
assigned to type <tt>t</tt>. But the interface <tt>mod2.zi</tt> will still use the
old stamp for <tt>mod1__t</tt> in the type of <tt>mod2__g</tt>. Hence, when
compiling <tt>mod3.ml</tt>, the system complains that the argument type of
<tt>mod2__g</tt> (that is, <tt>mod1__t</tt> with the old stamp) is not compatible
with the type of <tt>mod1__A</tt> (that is, <tt>mod1__t</tt> with the new stamp).
Fix: use <tt>make</tt> or a similar tool to ensure that all clients of a
module <i>mod</i> are recompiled when the interface <i>mod</i><tt>.zi</tt>
changes. To check that the <tt>Makefile</tt> contains the right dependencies,
remove all <tt>.zi</tt> files and rebuild the whole program; if no ``Cannot
find file'' error appears, you're all set.<P>
<dt>The type inferred for <i>name</i>,
	that is, <i>t</i>,
	contains non-generalizable type variables<dd>
Type variables (<tt>'a</tt>, <tt>'b</tt>, ...) in a type <i>t</i> can be in either
of two states: generalized (which means that the type <i>t</i> is valid
for all possible instantiations of the variables) and not generalized
(which means that the type <i>t</i> is valid only for one instantiation
of the variables). In a <tt>let</tt> binding <tt>let </tt><i>name</i><tt> = </tt><i>expr</i>,
the type-checker normally generalizes as many type variables as
possible in the type of <i>expr</i>. However, this leads to unsoundness
(a well-typed program can crash) in conjunction with polymorphic
mutable data structures. To avoid this, generalization is performed at
<tt>let</tt> bindings only if the bound expression <i>expr</i> belongs to the
class of ``syntactic values'', which includes constants, identifiers,
functions, tuples of syntactic values, etc. In all other cases (for
instance, <i>expr</i> is a function application), a polymorphic mutable
could have been created and generalization is therefore turned off.<P>
Non-generalized type variables in a type cause no difficulties inside
a given compilation unit (the contents of a <tt>.ml</tt> file,
or an interactive session), but they cannot be allowed in types
written in a <tt>.zi</tt> compiled interface file, because they could be used
inconsistently in other compilation units. Therefore, the compiler
flags an error when a <tt>.ml</tt> implementation without a <tt>.mli</tt> interface
defines a global variable <i>name</i> whose type contains non-generalized type
variables. There are two solutions to this problem:
<p><ul>
<li> Add a type constraint or a <tt>.mli</tt> interface to give a
monomorphic type (without type variables) to <i>name</i>. For instance,
instead of writing
<pre>
    let sort_int_list = sort (prefix &lt;);;
    (* inferred type 'a list -&gt; 'a list, with 'a not generalized *)
</pre>
write
<pre>
    let sort_int_list = (sort (prefix &lt;) : int list -&gt; int list);;
</pre>
<li> If you really need <i>name</i> to have a polymorphic type, turn
its defining expression into a function by adding an extra parameter.
For instance, instead of writing
<pre>
    let map_length = map vect_length;;
    (* inferred type 'a vect list -&gt; int list, with 'a not generalized *)
</pre>
write
<pre>
        let map_length lv = map vect_length lv;;
</pre>
</ul><P>
<dt><i>mod</i><tt>__</tt><i>name</i> is referenced before being defined<dd>
This error appears when trying to link an incomplete or incorrectly
ordered set of files. Either you have forgotten to provide an
implementation for the module named <i>mod</i> on the command line
(typically, the file named <i>mod</i><tt>.zo</tt>, or a library containing
that file). Fix: add the missing <tt>.ml</tt> or <tt>.zo</tt> file to the command
line.  Or, you have provided an implementation for the module named
<i>mod</i>, but it comes too late on the command line: the
implementation of <i>mod</i> must come before all bytecode object files
that reference one of the global variables defined in module <i>
mod</i>. Fix: change the order of <tt>.ml</tt> and <tt>.zo</tt> files on the command
line.<P>
Of course, you will always encounter this error if you have mutually
recursive functions across modules. That is, function <tt>mod1__f</tt> calls
function <tt>mod2__g</tt>, and function <tt>mod2__g</tt> calls function <tt>mod1__f</tt>.
In this case, no matter what permutations you perform on the command
line, the program will be rejected at link-time. Fixes:
<p><ul>
<li> Put <tt>f</tt> and <tt>g</tt> in the same module.
<li> Parameterize one function by the other.
That is, instead of having
<pre>
mod1.ml:    let f x = ... mod2__g ... ;;
mod2.ml:    let g y = ... mod1__f ... ;;
</pre>
define
<pre>
mod1.ml:    let f g x = ... g ... ;;
mod2.ml:    let rec g y = ... mod1__f g ... ;;
</pre>
and link <tt>mod1</tt> before <tt>mod2</tt>.
<li> Use a reference to hold one of the two functions, as in :
<pre>
mod1.ml:    let forward_g =
                ref((fun x -&gt; failwith "forward_g") : &lt;type&gt;);;
            let f x = ... !forward_g ... ;;
mod2.ml:    let g y = ... mod1__f ... ;;
            mod1__forward_g := g;;
</pre>
</ul><P>
<dt>Unavailable C primitive <i>f</i><dd>
This error appears when trying to link code that calls external
functions written in C in ``default runtime'' mode. As explained in
chapter <A HREF="node13.html#c:intf-c">13</A>, such code must be linked in ``custom runtime''
mode. Fix: add the <tt>-custom</tt> option, as well as the (native code)
libraries and (native code) object files that implement the required
external functions.<P>
</dl><P>
<HR>
<A HREF="node6.html"><IMG SRC="next_motif.gif"></A>
<A HREF="node4.10.html"><IMG SRC="previous_motif.gif"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif"></A>
